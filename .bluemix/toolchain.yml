version: '2'

template:
  name: "SECRETS_VIA_ENV_ENGINE"
  description: "SECRETS_VIA_ENV_ENGINE"
  required:
    - repo

  info:
    git url: >
      '[' + $env.repository + '](' + $env.repository + ')'
    git branch: >
      '[' + $env.branch + ']('+ $env.repository + '/tree/' + $env.branch + ')'

  $configuration:
    BASIC_WARNINGS: false
    ENABLE_EXTENSIONS: true
    ENABLE_SECRET_EXPANSION: true

toolchain:
  name: 'SECRETS_VIA_ENV_ENGINE'

services:
  repo:
    service_id: hostedgit
    parameters:
    
      # ------------------------------

      # Secret Reference Format:
      #
      # A secret is declared by reference in application code/annotations/resources
      # and resolved 'just-in-time' when required by a consumer (CI/CD, App runtime code, etc)
      #
      # Reference format specifies details to resolve a secret on IBM Cloud:
      #
      # "provider-type:region:resource-group:provider-instance-name:secret-name[:root-key-name]"
      #
      # Provider-Type:  kms | vault
      # Region:         us-south, eu-gb, etc
      #
      # eg:
      # 
      #     Reference to Key Protect provider type for 'my-secret' key in 'my-kms'
      #     Key Protect instance in 'default' resource-group on 'us-south' region
      #
      #     "kms:us-south:default:my-kms:my-secret"
      #
      # Consumers use the same common reference format regardless of handler/broker:
      #
      # eg:
      #     Shell:  MYSECRET=$(ibmcloud secrets get "kms:us-south:default:my-kms:my-secret")
      #
      #     JS:     let mysecret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret");
      #
      #     C++:    SECRET* secret = &ENV.retrieveSecret("kms:us-south:default:my-kms:my-secret");
      #
      #     yaml:   secret: $SECRET("kms:us-south:default:my-kms:my-secret")

      # ------------------------------
      
      # Secrets Management REST API:
      #
      # GET|PUT|POST|DELETE
      #   /secrets/providers/:provider_type/:instance_name/:secret_name?key&action&region&resource_group&resource_group_id
      #
      # GET|PUT|POST|DELETE
      #   /secrets/providers/:provider_type?secret_reference&action
      
      # ------------------------------
      
      # Standard Key (aka "secret") CRUD API:

      test1: >
        $env.createSecret("kms:us-south:default:my-kms:my-secret", "Hello World!")
        $env.retrieveSecret("kms:us-south:default:my-kms:my-secret")
        $env.updateSecret("kms:us-south:default:my-kms:my-secret", "Hello Mars!")
        $env.deleteSecret("kms:us-south:default:my-kms:my-secret")

      # ------------------------------
      
      # Root Key (aka "key") CRUD API:

      test2: >
        $env.createKey("kms:us-south:default:my-kms:my-root-key")
        $env.rotateKey("kms:us-south:default:my-kms:my-root-key")
        $env.deleteKey("kms:us-south:default:my-kms:my-root-key")

      # ------------------------------
      
      # Root Key and Standard Key wrapping/unwrapping via Root Key name reference:

      test3: >
        $env.createKey("kms:us-south:default:my-kms:my-root-key")
        $env.createSecret("kms:us-south:default:my-kms:my-secret:my-root-key", "Hello World!")  // wrapped
        $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key")                // unwrapped
        $env.updateSecret("kms:us-south:default:my-kms:my-secret:my-root-key", "Hello Mars!")   // rewrapped
        $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key")                // unwrapped

      # ------------------------------

      # 'wrap' the given plaintext using root key 'my-root-key'...
      test4: >
        let value = $env.wrapSecretValue("kms:us-south:default:my-kms:my-root-key", "Hello Jupiter!");
        console.log(value); // => "eyJjaXBoZXJ0ZXh0Ijoic1Zi"

      # 'unwrap' the given ciphertext using root key 'my-root-key'...
      test5: >
        let value = $env.unwrapSecretValue("kms:us-south:default:my-kms:my-root-key", "eyJjaXBoZXJ0ZXh0Ijoic1Zi");
        console.log(value); // => "Hello Jupiter!"

      # ------------------------------
        
      # scenario 1: involving self-managed secret and key rotation
      test6: >
        $env.createKey("kms:us-south:default:my-kms:my-root-key");
        $env.createSecret("kms:us-south:default:my-kms:my-secret:my-root-key", "Hello Mars!");
        
        // retrieve my-secret without specifying unwrapping root-key name...
        // in this case the encoded ciphertext is returned...

        let secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret");
        console.log(secret); // => "eyJjaXBoZXJ0ZXh0...kYTFmYzFhZiJ9"
        
        // whereas when the root-key name is suffixed to the end of the reference,
        // that root-key will be used to unwrap the secret and return the original
        // plaintext value of the secret...

        secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(secret); // => "Hello Mars!"
        
        // when the root-key gets rotated (it's key material is changed) either via
        // an API call or in the Key Protect Web UI, this means that any 'self-managed'
        // secret 'wrapped' with the pre-rotated root-key is now effectively defunct
        // and must have it's plaintext value updated and rewrapped with the newly
        // rotated root-key...

        $env.rotateKey("kms:us-south:default:my-kms:my-secret:my-root-key");
        
        // when trying to retrieve such a wrapped secret, where the original plaintext
        // value of the secret was provided (ie: imported), then upon subsequent retrieval
        // after root-key rotation, an HTTP/409/Conflict error will be returned indicating
        // the fact that the secret ciphertext cannot simply be unwrapped by the newly
        // rotated root-key...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(plaintext); // => "HTTP:409-Conflict: Secret cannot be 'unwrapped' with specified key."

        // this state requires admin/ops/owner intervention to update the secret with a new
        // plaintext value and by also specifying the root-key as a suffix of course, will
        // cause the secret to be rewrapped with the newly rotated root-key...
        
        $env.updateSecret("kms:us-south:default:my-kms:my-secret:my-root-key", "Hello Saturn!");

        // subsequent retrieval of the secret will then successfully return the new
        // updated plaintext value of the secret after unwrapping it with the newly
        // rotated root-key...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(plaintext); // => "Hello Saturn!"

      # ------------------------------
        
      # scenario 2: involving auto-managed secret and key rotation
      test7: >
        // the notable difference here between scenario 1 and this scenario 2, is
        // the fact that NO plaintext value is provided when creating the secret!
        // the underlying KMS will auto-generate the secret value AND take care
        // of updating/rewrapping the auto-generated secret value upon root-key
        // rotation...
        
        $env.createKey("kms:us-south:default:my-kms:my-root-key");
        $env.createSecret("kms:us-south:default:my-kms:my-secret:my-root-key"); // <-- auto-gen!
        
        // retrieve my-secret without specifying unwrapping root-key name...
        // in this case the encoded ciphertext is returned...

        let secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret");
        console.log(secret); // => "eyJjaXBoZXJ0ZXh0...kYTFmYzFhZiJ9"
        
        // whereas when the root-key name is suffixed to the end of the reference,
        // that root-key will be used to unwrap the secret and return the original
        // plaintext value of the secret...

        secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(secret); // => "ILchJu1xAvRVZFSWvm0Tf4QhW5cgHJqUvx9GivKJC68="
        
        // when the root-key gets rotated (it's key material is changed) either via
        // an API call or in the Key Protect Web UI, this means that any 'auto-managed'
        // secret 'wrapped' with the pre-rotated root-key is automatically updated and
        // rewrapped with the newly rotated root-key...

        $env.rotateKey("kms:us-south:default:my-kms:my-secret:my-root-key");
        
        // when trying to retrieve such a wrapped secret, the API internally recognises that
        // an 'auto-managed' secret is being requested and seamlessly manages the update
        // and rewrapping process before returning the new secret value...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(plaintext); // => "PRbhKu5xNvZvZFSYvm4Tf7QhW1cgHJeYvx0HivIKB99="

      # ------------------------------
        
      # scenario 3: involving auto-managed secret and key rotation with secret-type provider/broker
      test8: >
        // 
        
        $env.createKey("kms:us-south:default:my-kms:my-root-key");
        $env.createSecret("kms:us-south:default:my-kms:my-secret:my-api-key", "ibm-api-key");
        
        // retrieve my-secret without specifying unwrapping root-key name...
        // in this case the encoded ciphertext is returned...

        let secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-api-key");
        console.log(secret); // => "eyJjaXBoZXJ0ZXh0...kYTFmYzFhZiJ9"
        
        // whereas when the root-key name is suffixed to the end of the reference,
        // that root-key will be used to unwrap the secret and return the original
        // plaintext value of the secret...

        secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-api-key");
        console.log(secret); // => "IBMAPIKEY-ILchJu1xAvRVZFSWvm0Tf4QhW5cgHJqUvx9GivKJC68="
        
        // when the root-key gets rotated (it's key material is changed) either via
        // an API call or in the Key Protect Web UI, this means that any 'auto-managed'
        // secret 'wrapped' with the pre-rotated root-key is automatically refreshed via
        // the secret- type provider/broker as originally specified when created (eg: ibm-api-key)
        // and rewrapped with the newly rotated root-key...

        $env.rotateKey("kms:us-south:default:my-kms:my-secret:my-root-key");
        
        // when trying to retrieve such a wrapped secret, the API internally recognises that
        // an 'auto-managed' secret of a specified secret-type is being requested and
        // seamlessly manages the value refresh by requesting a new secret value from the
        // secret-type provider/broker again (eg: ibm-api-key type ==> ibm.createApiKey())
        // then rewraps before returning the new secret value...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-api-key");
        console.log(plaintext); // => "IBMAPIKEY-PRbhKu5xNvZvZFSYvm4Tf7QhW1cgHJeYvx0HivIKB99="

      # ------------------------------

form:
  pipeline:
    parameters:
      username: 'admin'
      group: 'system'
    schema:
      $ref: deploy.json
