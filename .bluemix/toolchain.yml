version: '2'

template:
  name: "SECRETS_VIA_ENV_ENGINE"
  description: "SECRETS_VIA_ENV_ENGINE"
  required:
    - repo

  info:
    git url: >
      '[' + $env.repository + '](' + $env.repository + ')'
    git branch: >
      '[' + $env.branch + ']('+ $env.repository + '/tree/' + $env.branch + ')'

  $configuration:
    BASIC_WARNINGS: false
    ENABLE_EXTENSIONS: true
    ENABLE_SECRET_EXPANSION: true

toolchain:
  name: 'SECRETS_VIA_ENV_ENGINE'

# {
#   "plaintext": "tF9ss0W9HQUVkddcjSeGg/MqZFs2CVh/FFKLPLLnOwY=",
#   "ciphertext": "eyJjaXBoZXJ0ZXh0Ijoic1ZZRnZVcjdQanZXQ0tFakMwRFFWZktqQ3AyRmtiOFJOSDJSTkpZRzVmU1hWNDJScDRDVythU0h3Y009IiwiaGFzaCI6IjVWNzNBbm9XdUxxM1BvZEZpd1AxQTdQMUZrTkZOajVPMmtmMkNxdVBxL0NRdFlOZnBvempiYUxjRDNCSWhxOGpKZ2JNR0xhMHB4dDA4cTYyc0RJMGRBPT0iLCJpdiI6Ilc1T2tNWFZuWDFCTERDUk51M05EUlE9PSIsInZlcnNpb24iOiIzLjAuMCIsImhhbmRsZSI6IjRkZjg5ZGVlLWU3OTMtNGY5Ny05MGNjLTc1ZWQ5YjZlNWM4MiJ9"
# }

services:
  repo:
    service_id: hostedgit
    parameters:

      # ------------------------------

      # create standard key 'cloud-apikey'...
      test1: >
        $env.createSecret("kms:us-south:default:tmg-kp-1:cloud-apikey", "Hello World!")

      # retrieve standard key 'cloud-apikey'...
      test1: >
        $env.retrieveSecret("kms:us-south:default:tmg-kp-1:cloud-apikey")

      # update standard key 'cloud-apikey'...
      # - assumes the secret already exists
      # - backs up existing key, deletes existing key, recreates new key
      test1: >
        $env.updateSecret("kms:us-south:default:tmg-kp-1:cloud-apikey", "Hello Mars!")

      # delete standard key 'cloud-apikey'...
      test1: >
        $env.deleteSecret("kms:us-south:default:tmg-kp-1:cloud-apikey")

      # ------------------------------

      # create master key 'root-key' if it doesn't already exist...
      test1: >
        $env.createKey("kms:us-south:default:tmg-kp-1:root-key")

      # create standard key 'cloud-apikey' after 'wrapping' the given value using master key 'root-key'...
      # - note: 'cloud-apikey' will contain the wrapped ciphertext afterwards
      #         if 'root-key' is deleted, then 'cloud-apikey' can never be 'unwrapped'!
      test1: >
        $env.createSecret("kms:us-south:default:tmg-kp-1:cloud-apikey:root-key", "Hello World!")
        
      # retrieve standard key 'cloud-apikey' and 'unwrap' it using master key 'root-key'...
      test1: >
        $env.retrieveSecret("kms:us-south:default:tmg-kp-1:cloud-apikey:root-key")

      # update standard key 'cloud-apikey' after 'wrapping' the given value using master key 'root-key'...
      # - assumes the secret and key already exists
      # - backs up existing key, deletes existing key, recreates new key
      # - note: 'cloud-apikey' will contain the wrapped ciphertext afterwards
      #         if 'root-key' is deleted, then 'cloud-apikey' can never be 'unwrapped'!
      test1: >
        $env.updateSecret("kms:us-south:default:tmg-kp-1:cloud-apikey:root-key", "Hello Mars!")

      # rotate master key 'root-key'...
      test1: >
        $env.rotateKey("kms:us-south:default:tmg-kp-1:root-key")

      # delete standard key and root key...
      test1: >
        $env.deleteKey("kms:us-south:default:tmg-kp-1:root-key")
        $env.deleteSecret("kms:us-south:default:tmg-kp-1:cloud-apikey")

      # ------------------------------

      # 'wrap' the given ciphertext using master key 'root-key'...
      test1: >
        let value = $env.wrapSecretValue("kms:us-south:default:tmg-kp-1:root-key", "Hello Jupiter!");
        console.log(value); // => "eyJjaXBoZXJ0ZXh0Ijoic1Zi"

      # 'unwrap' the given ciphertext using master key 'root-key'...
      test1: >
        let value = $env.unwrapSecretValue("kms:us-south:default:tmg-kp-1:root-key", "eyJjaXBoZXJ0ZXh0Ijoic1Zi");
        console.log(value); // => "Hello Jupiter!"

      # ------------------------------
        
      # scenario 1: involving self-managed secret and key rotation
      test1: >
        $env.createKey("kms:us-south:default:my-kms:my-root-key");
        $env.createSecret("kms:us-south:default:my-kms:my-secret:my-root-key", "Hello Mars!");
        
        // retrieve my-secret without specifying unwrapping root-key name...
        // in this case the encoded ciphertext is returned...

        let secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret");
        console.log(secret); // => "eyJjaXBoZXJ0ZXh0...kYTFmYzFhZiJ9"
        
        // whereas when the root-key name is suffixed to the end of the reference,
        // that root-key will be used to unwrap the secret and return the original
        // plaintext value of the secret...

        secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(secret); // => "Hello Mars!"
        
        // when the root-key gets rotated (it's key material is changed) either via
        // an API call or in the Key Protect Web UI, this means that any 'self-managed'
        // secret 'wrapped' with the pre-rotated root-key is now effectively defunct
        // and must have it's plaintext value updated and rewrapped with the newly
        // rotated root-key...

        $env.rotateKey("kms:us-south:default:my-kms:my-secret:my-root-key");
        
        // when trying to retrieve such a wrapped secret, where the original plaintext
        // value of the secret was provided (ie: imported), then upon subsequent retrieval
        // after root-key rotation, an HTTP/409/Conflict error will be returned indicating
        // the fact that the secret ciphertext cannot simply be unwrapped by the newly
        // rotated root-key...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(plaintext); // => "HTTP:409-Conflict: Secret cannot be 'unwrapped' with specified key."

        // this state requires admin/ops/owner intervention to update the secret with a new
        // plaintext value and by also specifying the root-key as a suffix of course, will
        // cause the secret to be rewrapped with the newly rotated root-key...
        
        $env.updateSecret("kms:us-south:default:my-kms:my-secret:my-root-key", "Hello Saturn!");

        // subsequent retrieval of the secret will then successfully return the new
        // updated plaintext value of the secret after unwrapping it with the newly
        // rotated root-key...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(plaintext); // => "Hello Saturn!"

      # ------------------------------
        
      # scenario 2: involving auto-managed secret and key rotation
      test1: >
        // the notable difference here between scenario 1 and this scenario 2, is
        // the fact that NO plaintext value is provided when creating the secret!
        // the underlying KMS will auto-generate the secret value AND take care
        // of updating/rewrapping the auto-generated secret value upon root-key
        // rotation...
        
        $env.createKey("kms:us-south:default:my-kms:my-root-key");
        $env.createSecret("kms:us-south:default:my-kms:my-secret:my-root-key"); // <-- auto-gen!
        
        // retrieve my-secret without specifying unwrapping root-key name...
        // in this case the encoded ciphertext is returned...

        let secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret");
        console.log(secret); // => "eyJjaXBoZXJ0ZXh0...kYTFmYzFhZiJ9"
        
        // whereas when the root-key name is suffixed to the end of the reference,
        // that root-key will be used to unwrap the secret and return the original
        // plaintext value of the secret...

        secret = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(secret); // => "ILchJu1xAvRVZFSWvm0Tf4QhW5cgHJqUvx9GivKJC68="
        
        // when the root-key gets rotated (it's key material is changed) either via
        // an API call or in the Key Protect Web UI, this means that any 'auto-managed'
        // secret 'wrapped' with the pre-rotated root-key is automatically updated and
        // rewrapped with the newly rotated root-key...

        $env.rotateKey("kms:us-south:default:my-kms:my-secret:my-root-key");
        
        // when trying to retrieve such a wrapped secret, where the original plaintext
        // value of the secret was provided (ie: imported), then upon subsequent retrieval
        // after root-key rotation, an HTTP/409/Conflict error will be returned indicating
        // the fact that the secret ciphertext cannot simply be unwrapped by the newly
        // rotated root-key...

        plaintext = $env.retrieveSecret("kms:us-south:default:my-kms:my-secret:my-root-key");
        console.log(plaintext); // => "PRbhKu5xNvZvZFSYvm4Tf7QhW1cgHJeYvx0HivIKB99="

      # ------------------------------

form:
  pipeline:
    parameters:
      username: 'admin'
      group: 'system'
    schema:
      $ref: deploy.json
